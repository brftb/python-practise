# -*- coding: utf-8 -*-
"""Untitled3-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k6OvNT-n571FO4kUAftbbcFWR1SCQHbL

# 辞書（dictionary）
## 連想配列のことじゃ
"""

ppap = {'apple' : 3, 'pen' : 5}
print(ppap)
print(type(ppap))
print(ppap['apple'])
# 値の変更と追加
ppap['apple'] = 10
ppap['pinapple'] = 7
print(ppap)
# 登録済かどうか調べる
print('apple' in ppap)
# 辞書の要素数
print("要素数：",len(ppap))
# 要素の削除
del ppap['apple']
print("削除後：",ppap)
# 空の削除
empty_d = {}
print(empty_d,"←これは空")

# 練習
def reverse_lookup(list1):
  dic = {}
  for i in range(len(list1)):
  # for i in list1:
    dic[list1[i]] = i
  return dic
print(reverse_lookup(['apple', 'pen', 'orange']) == {'apple': 0, 'orange': 2, 'pen': 1})

"""### 辞書のメソッド"""

ppap = {'apple' : 3, 'pen' : 5}
print('キーappleに対応する値：', ppap.get('apple'))
print('キーorangeに対応する値：', ppap.get('orange'))
print('（エラー）：', "ppap['orange']")
# get()の第２引数には「None」時に返す値を指定できる
print('apple：', ppap.get('apple', -1))
print('orange：', ppap.get('orange', -1))

# キーがない場合に登録を行う
ppap = {'apple' : 3, 'pen' : 5}
print('setdefault()を実行前の辞書：', ppap)
print('setdefault("apple", 7)：', ppap.setdefault('apple', 7))
print('setdefault("apple", 7)を実行後：', ppap)
print('setdefault("orange", 7)：', ppap.setdefault('orange', 7))
print('setdefault("orange", 7)を実行後：', ppap)
# 以下代用
if 'apple' not in ppap:
  ppap['apple'] = 7
if ppap.get('orange', -1) == -1:
# if ppap.get('orange', -1) is -1:
  ppap['orange'] = 77

# 全てのキーと値の削除→辞書は空となる。
ppap = {'apple' : 3, 'pen' : 5}
ppap.clear()
print(ppap)
print('=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=')
# キーの一覧を得る
ppap = {'apple' : 3, 'pen' : 5}
print(ppap.keys())
print(list(ppap.keys())) # listに変換して扱いやすくできる
print('=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=')
# 値の一覧を得る
print(ppap.values())
print(list(ppap.values())) # listに変換して扱いやすくできる
print('=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=')
# キーと値の一覧を得る
items = ppap.items()
print(items) # タプルにした一覧を返す
print(list(items)) # listに変換して扱いやすくできる
print('=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=')
print('=-=-=-=-=-=-=-=-==-=-=-=-=-=-=-=-=')
# 元の辞書が更新されると、これらの内容も動的に変わります。
ppap['kiwi'] = 9
print(ppap)
print(list(items))
print(type(list(items)[0]))

# 辞書を複製する
# リストの場合と同様に一方の辞書を変更してももう一方の辞書は影響を受けません。
ppap = {'apple': 3, 'pen': 5, 'orange': 7}
ppap2 = ppap.copy()
ppap['banana'] = 9
print('ppap : ',ppap)
print('ppap2 : ',ppap2)

# 辞書では値としてあらゆる型のデータを使用できる。
# 値としてリストを使用する辞書
numbers = {'dozens': [10, 20, 40], 'hundreds': [100, 101, 120, 140]}
print(type(numbers['dozens']) , numbers['dozens'])
print(numbers['dozens'][1])
# 逆に、辞書を要素とするリストを作成することもできる。
ppap = {'apple': 3, 'pen': 5}
pets = {'cat': 3, 'dog': 3, 'elephant': 8}
ld = [ppap, pets]
print(ld[1])
print(ld[1]['dog'])

# 練習
def handle_collision(dic1, str1):
  if dic1.get(len(str1), -1) == -1:
  # if dic1.get(len(str1)) is None:
    dic1[len(str1)] = [str1]
  else:
    dic1[len(str1)].append(str1) # listに追加
  return dic1
# handle_collision({1:['a']}, 'str1')
dic1_orig = {3: ['ham', 'egg'], 6: ['coffee', 'brandy'], 9: ['port wine'], 15: ['curried chicken']}
dic1_result = {3: ['ham', 'egg', 'tea'], 6: ['coffee', 'brandy'], 9: ['port wine'], 15: ['curried chicken']}
handle_collision(dic1_orig, 'tea')
print(dic1_orig == dic1_result)

